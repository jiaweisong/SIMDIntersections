
1234    2222 3333 4444 5555 6666

abcd    bbbb cccc dddd eeee ffff

// low gear:  1 rare compared with 1-20 freq (reshuffle if > 3)
//            5 per A if nextA0 not shared with A01
//            partial advance for freq (by ones? by twos? any divisor?)
//            Target 2:1 to 20:1 ratios
// No LOOKAHEADS --- use different algorithm if expected

// Goal:  consume all of rare in each pass.  advance freq as appropriate for next.

A(rare);
NUMVECS scales B(freq);

could share nextAA with AA1?
pshufd nextAA -> M1, M2, M3, M4;
pshufd nextAB -> ...


if maxA < B[0]  no match possible, A++;   // assymetric, A is rare
        
reload maxA;
    
if maxB  < A[0]  no match possible, B++;  // non-branching cmov
// Fine grained:  check max for each vector of B, partial increment
// if (maxDivisor < A[0]) B += DIVISOR

reload maxB;
// no looping

load nextA;

cmpeq M1,vecB0;
cmpeq M2,vecB0;
cmpeq M3,vecB0;
cmpeq M4,vecB0;

cmpeq M5,vecB0;
cmpeq M6,vecB0;
cmpeq M7,vecB0;
cmpeq M8,vecB0;

load vecB0;

might need to pshufd M1, M2, M3, M4 again;
// unless 1 rare vector and <= 2 freq
// 

maybe load nextA here if sharing M1;

or results; 

cmpeq M1,vecB1;
cmpeq M2,vecB1;
cmpeq M3,vecB1;
cmpeq M4,vecB1;
load vecB1;

or results; 

...NUMVECS

movmsk, popcnt, cmov add to count;

repeat




1 2 3 4  5  6  7  8   

4 3 2 1

2 4 6 8 10 12 14 16 

A0 < A1 < A2 < A3
B0 < B1 < B2 < B3



Realms:

Expect multiple matches within chunk
Expect match within chunk
Expect match within lookahead
Surprised by matches

Match vs Switch
Average run to switch
Matches per switch
Percent matches
Length ratio

#define ADVANCE_FREQ_BY_VECS(num)  {                                    \
            int advance = 0;                                            \
            if (freq[num * VECLEN - 1] < minRare) {                     \
                advance = GRANFREQ * VECLEN;                            \
            }                                                           \
            nextFreq += advance;                                        \
        }                                                                   

#define ADVANCE_RARE_BY_INTS(num) {                                     \
                int advance = 0;                                        \
                uint32_t minRare = rare[num];                           \
                if (maxFreq > minRare) {                                \
                    advance = GRANRARE * VECLEN;                        \
                }                                                       \
                nextRare += advance;                                    \
            }                                                           

#define CYCLE_RARE(rarenum, freqnum)                                \
        Rare = NextRare;                                            \
        if (rarenum + 1 < NUMRARE) {                                \
            VLOAD(NextRare, rare, num + 1);                         \
        } else if (freqnum + 1 < NUMFREQ) {                         \
            VLOAD(NextRare, rare, 0);                               \
        } else if (! lastPass) {                                    \
            VLOAD(NextRare, nextRare, 0);                           \
        }                                                           \
        VSHUF(F0, Freq, 0);                     \
                                                \
        VSHUF(F1, Freq, 1);                     \
        VMATCH(F0, Rare ## num);                \
                                                \
        VSHUF(F2, Freq, 2);                     \
        VMATCH(F1, Rare ## num);                \
        VOR(Match, F0);                         \
                                                \
        VSHUF(F3, Freq, 3);                     \
        VMATCH(F2, Rare ## num);                \
        VOR(Match, F1);                         \
                                                \
        VMATCH(F3, Rare ## num);                \
        VOR(Match, F2);                         \
                                                \
        VOR(Match, F3);                                   \
        int bits = _mm_movemask_ps((VECFLOAT) Match);              \
        matchBits |= bits << num


#define CHECK_VECTOR(num)                               \
        Freq = NextFreq;                                \
        if (num + 1 < NUMFREQ) {                        \
            VLOAD(NextFreq, freq, num);                 \
        }                                               \
        REPEAT_ADDING_ONE(CYCLE_RARE, NUMRARE, 0);      \


while (! lastPass) {
    uint32_t maxFreq = freq[NUMFREQ * VECLEN - 1];  // highest from freq vectors(s)
    uint32_t maxRare = rare[NUMRARE * VECLEN - 1];  // highest from rare vector(s)
    
    if (expected(maxFreq > maxRare)) {  // if all of Rare was already checked
        nextRare = rare + NUMRARE * VECLEN;         // jump to the next set of rare
    } else  {         // consider individually and reload (possibly unaligned)
        nextRare = rare;
        const uint32_t times = (NUMRARE * VECLEN / GRANRARE) - 1;
        REPEAT_INCREMENT(ADVANCE_RARE_BY_INTS, times, 0, GRANRARE);
    }
        
    // CHECK: make sure no reads extend beyond legal area
    uint32_t minRare = nextRare[0];

    const uint32_t times = (NUMFREQ / GRANFREQ);

    REPEAT_INCREMENT(ADVANCE_FREQ_BY_VECS, times, GRANFREQ, GRANFREQ);

    // FIXME: separate NextFreq from TempFreq, NextRare from TempRare
    if (nextFreq >= stopFreq || nextRare >= stopRare) {
        lastPass = 1;
    } else {
        VLOAD(NextFreq, nextFreq, 0);               
        VLOAD(NextRare, nextRare, 0);       
    } 

    // CHECK_VECTOR(0) ... CHECK_VECTOR(NUMFREQ-1)
    REPEAT_ADDING_ONE(CHECK_VECTOR, NUMFREQ, 0);

    freq = nextFreq;
    rare = nextRare;

    count += _mm_popcnt_u64(matchBits);
 }

FINISH_SCALAR:
return count; // plus scalar

